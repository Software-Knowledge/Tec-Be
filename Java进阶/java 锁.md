Java_锁
---
1. Java中我们往往使用锁来保证线程安全。
2. 滥用锁会导致锁顺序死锁。
3. 同样我们使用线程池和信号量来约束资源的使用。
4. Java应用不能从死锁中恢复，所以我们要熟悉死锁的先决条件

<!-- TOC -->

- [1. 逻辑角度:乐观锁和悲观锁](#1-逻辑角度乐观锁和悲观锁)
  - [1.1. 乐观锁](#11-乐观锁)
    - [1.1.1. 数据版本机制](#111-数据版本机制)
    - [1.1.2. CAS操作](#112-cas操作)
  - [1.2. 悲观锁](#12-悲观锁)
- [2. 线程数量角度:独享锁/共享锁](#2-线程数量角度独享锁共享锁)
  - [2.1. 独享锁](#21-独享锁)
  - [2.2. 共享锁](#22-共享锁)
  - [2.3. 具体实现:互斥锁/读写锁](#23-具体实现互斥锁读写锁)
  - [2.4. 可重入锁](#24-可重入锁)
- [3. 获取锁的角度:公平锁/非公平锁](#3-获取锁的角度公平锁非公平锁)
  - [3.1. 公平锁](#31-公平锁)
    - [3.1.1. AQS(AbstractQueuedSynchronizer)](#311-aqsabstractqueuedsynchronizer)
  - [3.2. 非公平锁](#32-非公平锁)
- [4. 锁的设计:分段锁](#4-锁的设计分段锁)
- [5. 根据锁的状态:偏向锁/轻量级锁/重量级锁](#5-根据锁的状态偏向锁轻量级锁重量级锁)
  - [5.1. 偏向锁](#51-偏向锁)
  - [5.2. 轻量级锁](#52-轻量级锁)
  - [5.3. 重量级锁](#53-重量级锁)
- [6. 自旋锁](#6-自旋锁)
- [7. 死锁](#7-死锁)
  - [7.1. 死锁发生的条件](#71-死锁发生的条件)
  - [典型死锁](#典型死锁)
- [8. 参考](#8-参考)

<!-- /TOC -->

# 1. 逻辑角度:乐观锁和悲观锁
1. 乐观锁和悲观锁并不是特指某两种类型的锁，是人们定义出来的概念和思想，主要是在并发同步的角度。

## 1.1. 乐观锁
1. 认为不存在并发问题，认为不会有其他线程对数据进行修改，因此不上锁。
2. 但是在使用的时候，我们会通过数据版本机制或者CAS操作来实现检查有无数据修改。
3. 多用于多读的逻辑中，提高吞吐量。在java中`java.util.concurrent.atomic`包里面的原子变量类就是使用乐观锁的一种实现方式`Compare and Swap`实现。

### 1.1.1. 数据版本机制
1. 实现方式一:使用版本号，数据表中加上上一个数据版本的version版本号，标识数据被修改的次数。
   1. 数据被修改一次，version++。
   2. 读取数据的同时读取version，只有相等才能更新，否则重试更新操作，直到成功
2. 实现方式二:使用时间戳

### 1.1.2. CAS操作
1. 多个线程尝试使用CAS更新同一个变量的时候，只有一个线程可以更新变量的值，而其他线程都会失败并且被告知可以再次尝试。
2. 包含的操作数:
   1. 需要读取的内存地址:V
   2. 进行比较的预期原值:A
   3. 拟写入的新值:B
3. 如果V和A相匹配，则会更新为B，否则不更新。

## 1.2. 悲观锁
1. 对于同一个数据的并发操作一定会发生。
2. 使用加锁的方式。
3. 在数据修改前，应该为正在修改的数据加上排它锁(exclusive locking)，如果加锁失败，则说明正在修改，对应线程等待或者异常

# 2. 线程数量角度:独享锁/共享锁

## 2.1. 独享锁
1. 一个锁只能被一个线程持有

## 2.2. 共享锁
1. 一个锁可以被多个线程持有

## 2.3. 具体实现:互斥锁/读写锁

## 2.4. 可重入锁
1. 如果某个线程视图获取一个已经由他自己持有的锁，则这个请求可以成功。
```java
public void get() {
        lock.lock();
        System.out.println(Thread.currentThread().getId());
        set();
        lock.unlock();
    }

public void set() {
        lock.lock();
        System.out.println(Thread.currentThread().getId());
        lock.unlock();
}
```

# 3. 获取锁的角度:公平锁/非公平锁

## 3.1. 公平锁
1. 公平锁是指多个线程按照申请锁的顺序来获取锁。

### 3.1.1. AQS(AbstractQueuedSynchronizer)
1. `AbstractQueuedSynchronizer`为实现依赖于先进先出 (FIFO) 等待队列的阻塞锁定和相关同步器(信号量、事件，等等)提供一个框架。
2. 此类的设计目标是成为依靠单个原子 int 值来表示状态的大多数同步器的一个有用基础。
3. 子类必须定义更改此状态的受保护方法，并定义哪种状态对于此对象意味着被获取或被释放。
4. 假定这些条件之后，此类中的其他方法就可以实现所有排队和阻塞机制。但只是为了获得同步而只追踪使用 getState()、setState(int) 和 compareAndSetState(int, int) 方法来操作以原子方式更新的 int 值。

## 3.2. 非公平锁
1. 非公平锁是多个线程获取锁的顺序并不是按照申请锁的顺序。
2. 对于`ReetrantLock`而言，可以通过构造函数来指定一个锁是不是公平锁，默认为非公平锁，因为非公平锁的吞吐量大于公平锁的吞吐量。
3. 对于`Synchronized`而言，是一种非公平锁，但是不是类似`ReetrantLock`那样通过AQS来实现线程调度。

# 4. 锁的设计:分段锁
1. 分段锁其实是一种锁的设计方式。
2. 对于`ConcurrentHashMap`而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。
3. 以`ConcurrentHashMap`为例，其中的分段锁称为`Segment`，它即类似于`HashMap`的结构，即内部拥有一个`Entry`数组，数组中的每个元素又是一个链表；同时又是一个`ReentrantLock`(`Segment`继承了`ReentrantLock`)。
4. 当需要put元素的时候，并不是对整个`hashmap`进行加锁，而是先通过`hashcode`来知道他要放在哪一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。
5. 但是，在统计size的时候，可就是获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计。
6. 分段锁的设计目的是**细化锁的粒度**，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。

# 5. 根据锁的状态:偏向锁/轻量级锁/重量级锁
1. 这三种锁是指锁的状态，并且是针对`Synchronized`。在Java 5通过引入锁升级的机制来实现高效`Synchronized`。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。

## 5.1. 偏向锁
1. 偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。

## 5.2. 轻量级锁
1. 轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。

## 5.3. 重量级锁
1. 重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让他申请的线程进入阻塞，性能降低。

# 6. 自旋锁
1. 在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。

# 7. 死锁

## 7.1. 死锁发生的条件
1. 互斥使用，一个线程占用了资源，其他线程不能使用
2. 不可争抢，资源请求者不能强行获取资源，只能资源拥有者自行释放
3. 请求和保持，当资源拥有者在请求其他资源的同时，保持原有资源的拥有
4. 循环等待，存在一个环状等待序列

## 典型死锁
1. 静态的锁顺序死锁:所有需要多个锁的线程，都应该使用相同的顺序来获取锁
2. 动态的锁顺序死锁:使用`System.identifyHashCode`来定义锁的顺序，确保所有线程都使用相同的顺序来获取锁
3. 写对象之间的死锁:需要使用开发调用，避免在持有锁的情况下调用外部的方法

# 8. 参考
1. <a href = "https://pppppkun.github.io/2019/12/12/Java并发常见锁/">Java锁的分类</a>
2. <a href = "https://www.jianshu.com/p/1ea068ae367c">https://www.jianshu.com/p/1ea068ae367c</a>