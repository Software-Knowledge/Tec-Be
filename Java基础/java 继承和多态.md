<!-- TOC -->

- [1. java学习笔记之继承和多态](#1-java学习笔记之继承和多态)
  - [1.1. 继承](#11-继承)
    - [1.1.1. 继承源起](#111-继承源起)
    - [1.1.2. 继承特点](#112-继承特点)
    - [1.1.3. 问题：子类继承了父类所欲的成员变量和方法，是否包含父类的私有变量？](#113-问题子类继承了父类所欲的成员变量和方法是否包含父类的私有变量)
    - [1.1.4. super关键字](#114-super关键字)
    - [1.1.5. IS-A&&HAS-A&&USES-A&&OWNS-A](#115-is-ahas-auses-aowns-a)
    - [1.1.6. 父类对于子类的影响](#116-父类对于子类的影响)
  - [1.2. 组合](#12-组合)
  - [1.3. 对于继承和组合的选择](#13-对于继承和组合的选择)
  - [1.4. 可修改性](#14-可修改性)
    - [1.4.1. 用户端代码](#141-用户端代码)
  - [1.5. 多态](#15-多态)
  - [1.6. 方法的字节码调用](#16-方法的字节码调用)
- [2. 初始化过程](#2-初始化过程)

<!-- /TOC -->
# 1. java学习笔记之继承和多态

## 1.1. 继承
1. 继承是指利用已有类的形式，并添加新的成员变量和方法来构建新的类。
2. 父类不可以强制类型转换成子类
3. java单一继承，而不是多继承
```java
class Base{}
class Sub extends Base{}
class Sub2 extends Base{}
public class Test{
      public static void main(String args[]){
            Base b = new Base();
            Sub s = (Sub) b;
      }
} //编译通过，但运行是出错
```
### 1.1.1. 继承源起
1. 避免重复代码
2. 分类、抽象的概念
3. 根父类：Object
    1. toString()方法
    2. equals()方法
    3. wait()方法

### 1.1.2. 继承特点
1. 子类继承了父类所有成员变量和方法
2. 继承可以增加成员变量和成员方法
3. 继承可以覆盖父类的成员方法
4. 继承不可以覆盖父类的成员变量
    + 父类中的方法如果是private，不能调用子类重写的方法
5. 重名方法会调用继承树最下方部分的方法
6. 父类设置了一种契约，所有的子类都会承受这个契约
7. **任何一个子类对象都可以当做父类来看待**
8. 子类写的和父类同名的方法算一个方法，是对父类的重写
9. 子类变量可以被赋值给父类引用
10. **父类不可以强制类型转换成子类**

### 1.1.3. 问题：子类继承了父类所欲的成员变量和方法，是否包含父类的私有变量？
1. 能够继承父类的私有变量
2. 但是不能直接访问父类的私有变量

### 1.1.4. super关键字
1. 如果你在子类中重写了父类的方法，但是想要使用父类中未被重写的方法，那么使用super关键字来完成引用  
2. 几个实例
```java
class father{
    private int a;
    public father(int a){
        this.a = a;
    }
}
class son extends father{
    public son(int a){
        super(a);
    }
}
```

### 1.1.5. IS-A&&HAS-A&&USES-A&&OWNS-A
1. IS-A是继承机制
2. HAS-A是是否被继承机制
3. USES-A是依赖关系
4. HAS-A是关联关系
5. OWNS-A是聚合关系
6. IS-A-PART-OF是组合关系

### 1.1.6. 父类对于子类的影响
1. 父类的接口的更改会影响所有的子类的接口。
2. 子类继承父类的私有变量、接口等。
3. 从构造方法开始，向上调用父类方法
4. 编译器会自动帮你调用super()(也就是无参数的构造函数)，而如果写的话必须在开头
6. 从接口来看：
    1. 子类必须保持和父类同样的接口
    2. 子类必须继承了父类的实现
    3. 一旦父类脆弱发生变化，就会对子类造成很大的麻烦


## 1.2. 组合
1. 一个类里面有一个属性，将一个fruit组合进入Apple中
2. 允许你在新的类中设置子对象，组合是显式的这样做，而继承是隐式的这样做。
3. 使用组合关系时，前端接口和后端接口没有直接关系，只要修改实现就好
4. 组合主要用于想要在新类中使用现有类的功能而并不是它的接口的情形

## 1.3. 对于继承和组合的选择
1. 确保有继承关系
2. 不要使用继承去完成代码的重载
3. 确认父类方法的接口稳定性

## 1.4. 可修改性
1. 特点：
    1. 对已有实现的修改
    2. 对新的实现的扩展
    3. 对实现的动态配置

### 1.4.1. 用户端代码
1. 特点：
    1. 大量的
    2. 分散的
    3. 如何发生修改重新编译的话，是需要大量时间的
    >不想要更改
2. 构造方法没有多态

## 1.5. 多态
1. 多态是指多个成员变量或成员方法采用相同的标识符，并且在使用该标识符时确认应该使用哪个成员变量或成员方法。
2. 所有类的父类:Object
    1. `equals(Object o) `指示某个其他对象是否与此对象"相等"。 
    2. `getClass() `返回一个对象的运行时类。
    3. `hashCode() `返回该对象的哈希码值。
    4. `toString() `返回该对象的字符表示。
3. 多态的代价：Object不能添加Dog类型的变量。
4. 编译时，编译器决定你是否能调用某个方法
    + 依据引用变量的类型，而不是引用变量指向的对象的类型
5. 执行时，JVM虚拟机决定实际那个方法被调用
    + 依据实际引用变量指向的对象的类型
6. 多态的思想:分离"做什么"和"怎么做"，从另一角度将接口和实现分离开来。
7. Overriding规则:
    1. 参数必须一致，返回值必须兼容
    2. 方法的可达性不可降低(private、public)
    3. 不可以覆盖私有方法，因为父类私有方法自动添加final
8. Overloading
    1. 静态分派：
        1. 优先级:char>int>long>Character>Serializable>Object>char...
        2. 如果不存在char的，优先匹配int，以此类推
        3. 编译的时候就已经决定了这个调用的优先顺序
    2. 动态分派：
        1. 在编译器中，重写的方法被视作了一个方法
        2. 按照类型进行分派

## 1.6. 方法的字节码调用
1. 参PPT

# 2. 初始化过程
1. 步骤如下：  
    1. 首先加载一条链上的各个类
    2. 先进行静态初始化，优先初始化父类，之后初始化子类
    3. 将所有的成员变量先设置为0系的初值
    4. 开始调用父类的构造方法，一条链向上
    5. 将所有的成员变量按照字面顺序初始化
    6. 剩余的所有的部分的初始化
2. 考察构造顺序
