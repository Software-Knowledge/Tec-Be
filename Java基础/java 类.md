<!-- TOC -->

- [1. 类](#1-类)
    - [1.1. 类和对象](#11-类和对象)
    - [1.2. 创建类的原因](#12-创建类的原因)
    - [1.3. 类创建在堆上，类的成员:](#13-类创建在堆上类的成员)
    - [1.4. 使用的功能性关键字](#14-使用的功能性关键字)
    - [1.5. 作用域问题](#15-作用域问题)
    - [1.6. 外部类的调用](#16-外部类的调用)
    - [1.7. 类的构造方法](#17-类的构造方法)
    - [1.8. 不可变类](#18-不可变类)
        - [1.8.1. StringBuffer和StringBuilder](#181-stringbuffer和stringbuilder)
        - [1.8.2. String.intern()方法](#182-stringintern方法)
        - [1.8.3. 类图：](#183-类图)
    - [1.9. 抽象类和抽象方法](#19-抽象类和抽象方法)
        - [1.9.1. 抽象类](#191-抽象类)
        - [1.9.2. 抽象方法](#192-抽象方法)
        - [1.9.3. 类的初始化](#193-类的初始化)
        - [静态初始化](#静态初始化)
    - [1.10. 访问权限](#110-访问权限)
- [2. 基本数据类型的包装类](#2-基本数据类型的包装类)
    - [2.1. 包装类的用途](#21-包装类的用途)
    - [2.2. 自动装箱和拆箱](#22-自动装箱和拆箱)
- [3. 内部类](#3-内部类)
- [4. 类之间的关系](#4-类之间的关系)

<!-- /TOC -->
# 1. 类
1. 类的定义：是描述相同事物的集合，以概要的方式描述了相同事物集合中的所有元素，但却允许类中的每一个实体元素可以在非本质特征上变化
2. 另一种定义：面向对象程序设计中最基本的概念，定义了一个事物的抽象特征，定义了事物的属性和对属性的操作（行为）。是一种抽象数据类型，即某类数据结构和其所具有行为的集合。
`class`关键词。

## 1.1. 类和对象
1. 类是对某个对象的定义
2. 类包含相关对象的动作方式的信息
3. 引用类的代码运行时，类的新实例对象就在内存中创建了
4. 类应当有单一职责

## 1.2. 创建类的原因
1. 对现实世界中对象的建模
2. 对抽象对象建模
3. 降低复杂度
4. 隔离复杂度
5. 隐藏实现细节
6. 限制变化影响的范围
7. 创建中心控制点

## 1.3. 类创建在堆上，类的成员:
   + 成员变量
   + 成员方法

## 1.4. 使用的功能性关键字
关键字|作用
--|--
返回值|返回一个值
`return`|提供返回值
`extends`|表示继承关系
`new`|用于新建
`.`|用来引用访问类内部成员 

## 1.5. 作用域问题
1.java的对象不具备和基本数据类型相同的生命周期。  
2.java的对象在解除引用后需要考虑如何释放内存。  

## 1.6. 外部类的调用
1.关键字：`import`  
2.更加常见的是同时导入一个类的所有方法。 

## 1.7. 类的构造方法
1. 方法名称和类名相同，参数不同，没有返回值
2. 构造方法用于初始化一个类

## 1.8. 不可变类
1. 不可变字符串
2. java对于字符串的特殊处理：
   1. 两种定义方式：
      + `String name = "Tom"`这样子不会新建内存
      + `String name = new String("Tom")`
   2. 你在赋值时`name = "Bob"`,虚拟机不改变原来的对象，生成一个新的String对象，让name指向他，之后被解引用的会被回收。
   3. 使用`+`来生成字符串是一个非常浪费时间的操作
### 1.8.1. StringBuffer和StringBuilder
1. StringBuffer:支持多线程
   1. 创建一个新的对象`StringBuffer sb = new StringBuffer(string.length*times//可选)`
   2. 添加方法`.append()`
2. StringBuilder:不支持多线程
   1. 创建一个新对象`StringBuilder name = new StringBuilder()`
   2. 添加方法`.append()`

### 1.8.2. String.intern()方法

### 1.8.3. 类图：
1. <a href = "https://blog.csdn.net/soft_zzti/article/details/79811923">统一建模语言（UML)</a>  
name + instance variables + methods 
>UML：  
   1. 分为四层，使用抽象概念（接口和继承）
   2. 可以在毕业设计中使用
2. 空心三角和实心直线表示继承
3. 虚线表示抽象

## 1.9. 抽象类和抽象方法
1. 关键字`abstract`

### 1.9.1. 抽象类
1. 有一些类不应该实例化
2. 抽象类本身没有用，除非他被继承，有了子类。抽象类的子类可以实例化。
3. 非抽象类中不可以有抽象方法
4. 抽象类中可以有非抽象方法(非抽象方法表示已经被实现了)

### 1.9.2. 抽象方法
1. 抽象方法的存在就是为了多态
2. 具体的类必须实现所有的抽象方法
3. 实现抽象方法就像子类覆盖父类方法一样

### 1.9.3. 类的初始化
1. 类的初始化的步骤
    1. 加载：由类加载器执行，查找字节码，并创建一个Class对象
    2. 链接：验证字节码，为静态域分配空间(只是分配，并不初始话该存储空间)，解析该类创建所需要的对其他类的应用
    3. 初始化：首先执行静态初始化块static，初始化静态变量，执行静态方法(如构造方法)
        + 先加载直到加载到本身的父类
        + 然后进行逐一的静态初始化
        + 对于所有变量进行初始化
        + 调用父类构造函数
        + 局部变量按照字面顺序被初始化
        + 剩下的部分的构造函数的运行
2. 可能对了执行初始化的操作:
    1. 创建一个java类的实例对象
    2. 调用了一个java类的静态方法
    3. 为类或接口中的静态域赋值
    4. 访问类或接口中声明的静态域，并且该域的值不是常值变量
    5. 在一个顶层的java类中执行assert语句
    6. 调用Class类和反射API中进行反射操作
3. 注意:当访问一个java类或接口的静态域时，只有真正声明这个域的类或接口才会被初始化

### 静态初始化
1. 所有变量先初始化，优先于构造方法
2. 先初始化静态变量，然后是非静态的
3. 静态变量按照字面顺序进行初始化
## 1.10. 访问权限
1. private:仅可以由包含该成员变量或者成员方法的类访问，用于防止对象的成员变量被非法修改或者某些仅供对象自身使用的方法。
2. public：可以被所有类访问，用于对外提供的服务
3. protected：对于自己的子类是可见的
4. 默认权限：可以被同一个包中的其他类访问。同一个包中的类名不可重复。所有没有显示指定所属包的类都位于同一个包中。

# 2. 基本数据类型的包装类
1. 我们在实际使用中经常需要将基本数据转化成对象，便于操作。
2. 为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，这样八个和基本数据类型相应的类统称为包装类
3. 包装类

基本数据类型|包装类
--|--
byte|Byte
boolean|Boolean
short|Short
char|Character
int|Integer
long|Long
float|Float
double|Double
1. java中每个基本数据类型都有一个对应的封装类
2. 封装类包含的值可以通过equals()进行比较
3. 封装类包含的值不可以通过value()进行比较
4. 封装类除了Character类外，都可以作为构造方法的实参创建实例

## 2.1. 包装类的用途
1. 包装类包含每种数据类型的相关属性如最大值、最小值等，以及相关的操作方法。
2. 提供了基本类型之间的转化方法、基本类型和对象和字符串之间相互转化的方法。

## 2.2. 自动装箱和拆箱
1. 自动装箱过程：每当需要一种类型的对象时，这种基本类型就自动地封装到与它相同类型的包装中
2. 自动拆箱过程：每当需要一个值时，被装箱对象中的值就被自动的提取出来，没必要再去调用intValue()和doubleValue()方法。
3. 实际上我们的赋值语句是这样子。`Integer i = 100; -> Integer i  = new Integer(100);`



# 3. 内部类
1. 内部类可以使用外部所有方法与变量，就算是私有的也一样
2. 内部类提供了在一个类中实现同一接口的多次机会

# 4. 类之间的关系
1. 多态
2. 实现：一个类和一个接口
3. 聚合：7个队员组成1个球队
    + 指新类中采用已有类的对象作为其成员变量，并增加其他的成员变量来表示其属性
4. 继承
5. 关联：你和你的老师
6. 泛化:某些类之间存在一般元素和特殊元素的关系
7. 依赖：一种使用关系，表现为一样事物的改变会影响到使用它的其他事物。
8. 组合：大体同聚合，但是部分必须依赖整体而存在，比如人和大脑