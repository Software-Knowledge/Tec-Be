<!-- TOC -->

- [1. 内存和虚拟机](#1-内存和虚拟机)
  - [1.1. 内存](#11-内存)
  - [1.2. 虚拟机](#12-虚拟机)
- [2. java的编译和运行](#2-java的编译和运行)
  - [2.1. 编译期](#21-编译期)
  - [2.2. 运行期](#22-运行期)
  - [2.3. 解释器](#23-解释器)
- [3. JVM和字节码](#3-jvm和字节码)
  - [3.1. 存储方式](#31-存储方式)
  - [3.2. 字节码](#32-字节码)
  - [3.3. Class文件结构](#33-class文件结构)
    - [3.3.1. 参考图像](#331-参考图像)
  - [3.4. 整体字节码：(按照顺序)](#34-整体字节码按照顺序)
    - [3.4.1. 运行时数据区](#341-运行时数据区)
  - [3.5. 字节码指令集](#35-字节码指令集)
    - [3.5.1. 指令分类](#351-指令分类)
    - [3.5.2. 前后缀](#352-前后缀)
    - [3.5.3. 加载和存储指令](#353-加载和存储指令)
    - [3.5.4. 运算指令](#354-运算指令)
    - [3.5.5. 类型转换指令](#355-类型转换指令)
    - [3.5.6. 对象创建于访问命令](#356-对象创建于访问命令)
    - [3.5.7. 操作数栈管理指令](#357-操作数栈管理指令)
    - [3.5.8. 控制转移指令](#358-控制转移指令)
    - [3.5.9. 方法调用和返回指令](#359-方法调用和返回指令)
    - [3.5.10. 异常处理指令](#3510-异常处理指令)
    - [3.5.11. 同步指令](#3511-同步指令)
  - [3.6. 字节码在虚拟机中的执行](#36-字节码在虚拟机中的执行)
    - [3.6.1. 类的声明周期](#361-类的声明周期)
  - [3.7. java指令和字节码](#37-java指令和字节码)
    - [3.7.1. 变量](#371-变量)
    - [3.7.2. 条件语句](#372-条件语句)
    - [3.7.3. 循环语句](#373-循环语句)
    - [3.7.4. 方法调用](#374-方法调用)

<!-- /TOC -->

# 1. 内存和虚拟机

## 1.1. 内存
1. 逻辑内存地址空间(Linux操作系统空间)
   1. 内核空间
   2. 堆：从高向低分配
   3. 栈：局部变量:从低向高分配
   >ebp：Main函数的栈针底部  
   >esp:栈针顶部  
   4. 代码段
2. <a href = "file:///D:/南京大学/大一第二学期/软件工程与计算1-2019/课件/08%20-%20结构化编程%20III%20-%20方法.pdf">JVM 51页</a>  
   1. 方法区
   2. 引用类型变量对java对象访问的实现
      + 访问数据
         + 实例数据值(对象中各个实例字段的数据)
         + 对象类型数据
      + 访问方式
         + 句柄方式访问：像是key一样
         + 直接指针访问

## 1.2. 虚拟机
1. 是机器的软件实现，可以像物理机一样执行程序
2. JVM的特性：
    1. 基于栈的虚拟机：
        + JVM基于栈进行运行
    2. 标识符引用：
        + 所有类型(类和接口)除了基本类型(又称原始类型)都是通过表示符引用的，而不是显示的基于内存地址的引用
    3. 垃圾收集：
        + 一个类的实例是由用户代码显式创建的并通过垃圾收集自动销毁
    4. 通过清除的定义基本数据类型保证平台的独立
        + JVM清除地定义了原始数据类型以维持兼容性和保证跨平台的能力。
    5. 网络字节顺序
        + JVM使用网络字节序，它是一种网络传输的顺序，网络字节序是big endian的
# 2. java的编译和运行

## 2.1. 编译期
1. 静态绑定
2. 多分派
3. overloading
4. 编译：将整个程序源代码翻译成另一种代码，然后等待被执行，发生在运行之前，产物是另一份代码

## 2.2. 运行期
1. 动态绑定
2. 单分派
3. overriding
4. 强制类型转换在改阶段进行->会带来异常

## 2.3. 解释器
将程序源代码一行行的读懂，然后执行，发生在运行时，产物是运行结果。

# 3. JVM和字节码

## 3.1. 存储方式
java对象在JVM中的存储：
1. 对象头：8b
2. java原始类型数据：
3. 引用：4b
4. 填充符

## 3.2. 字节码
1. java代码最后被编译成了字节码,字节码在虚拟机中被执行
2. 字节码的语言无关性(不同语言被相应编译器编译后运行)
3. `.class`文件就是字节码
4. 查看字节码
   1. `javac test.java`
   2. `javap -verbose test`//打开参考区域
5. constant pool:常量池

## 3.3. Class文件结构
+ 一组以8位字节为基础单位的二进制流
+ 魔数(magic)文件开头
+ 版本号(副版本号+朱版本号)
+ 常量池计数器
+ 常量池数据区：(单独写出来的部分)
   + 字面量
   + 符号引用
+ 访问标志
+ 类索引:
    1. 有两个字节组成
    2. 两个字节中存储的值是某个变量池中的变量池常量池项CONSTANT_Class_info的索引
    3. 这个索引会进一步指向常量池项CANSTANT_Utf8_info，这项表示此类的完全先定名字符串
+ 父类索引(依据常量池)
+ 接口计数器
+ 接口信息数据区
+ 字段计数器
+ 字段信息数据区
+ 方法计数器
+ 方法信息数据区
+ 属性计数器
+ 属性信息数据区(代码的实现会被作为一个属性值)

### 3.3.1. 参考图像
1. 字节码图片(第一章)
   + 4：主版本号5：次版本号
   + 6、7：长度
2. 第二张图片：
   + class 名字叫2，看2，可知包+名称
   + 0x14 = 20字节表示类的名字
   + 01代表utf8下一个

## 3.4. 整体字节码：(按照顺序)
1. 首先是访问标志(访问这个类？)
2. 然后是类索引(其中的值指向常量池中的值)
>如果常量池中保存的值依旧是索引，则继续指向常量池中的其他值
3. 之后是父类索引：通过查父类索引获得这个类是继承自哪个父类
4. 父类索引后就是接口索引集合(接口计数器+接口信息数据区)
    1. 接口计数器：用来获得接口有多少个
    2. 接口索引集合：用于保存在常量池中的索引集合
    3. field_info结构体(JVM定义的)
        1. 字段表示：作用域+静态or非静态+可变性+并发可见性+是否可序列化+数据类型+字段名称+其他属性
        2. 结构体实例
        ```java
        Field_info{
            u2 access_flags;//前五项
            u2 name_index;//字段名称
            u2 descriptor_index;//数据类型
            u2 attribute_count;//其他属性
            attribute_info attributes;//其他属性
        }
        ```
        3. 存储格式：访问标志+名称索引+描述索引+属性计数器+many constantValues
        4. 3中的ConstantValue格式如下：属性名称索引(字符串的值为"ConstantVaule")+属性长度(对应后面的常量值索引的字节长度，固定为2)+常量值索引(其中的值是赋给field字段的值)
        5. 图片参见ppt
5. 方法表集合：
    1. 方法计数器
    2. 方法信息数据区
    3. 方法表示：作用域+静态or非静态+可变性+是否同步+是否本地方法+是否抽象+方法描述+方法名称+方法内机器指令、异常信息、是否声明为deprecated
    4. method_info例子：属性表集合
        ```
        method_info{
            u2 access_flags;
            u2 name_index;
            u2 descriptor_index;
            u2 attribute_count;
            attribute_info attributes；
        }
        ```
    5. 存储形式：访问标志+名称索引+描述索引+属性计数器+many Attribute_info
    6. 5中的constantValue的格式：属性名称索引(字符串在常量池项中表示为"ConstantValue")+属性长度(一般固定为2)+常量值索引(表示要复制给field字段的值)
        1. 属性名称索引：
            1. 占有两个字节，其中的值指向常量池中的某一项，该项表示的字符串表这个attribute——info是什么属性的属性表。
                + Code:表示这个属性表记录的是机器码
                    1. 格式：机器指令+异常处理跳转信息+java源码行号和机器源码对应关系+局部变量表描述信息
                    2. 具体参见ppt
                 + Exception：表示这个属性表记录的是异常信息
                + Deprecated：表示这个属性表记录的是被@Deprecated修饰的
                + Synthetic：表示此属性表被编译器自动生成
            2. 对于不同类型的属性表，他们的**属性长度和组织形式**是不同的
                1. 属性长度：如果值为n,则之后的n个字节是用来表示属性信息
                2. 属性值：由若干个字节构成，字节的个数由属性长度中的值决定
    7. 文件实例：参见PPT中
        1. 棕色字段：编译器自动生成的构造函数`<init>`
        2. `()V`表示无返回值的void
        3. 对于Code类型属性表，其Attribute_info的格式是：属性名称索引+属性长度+栈的最大深度+局部变量表最大值+机器指令数目+机器指令+异常表+属性表集合
        4. 仔细参考40页
5. 常量池中的信息大多按照字符串形式保存，按照之前规定的编码进行翻译

### 3.4.1. 运行时数据区
1. 组成
    1. PC计数器：存了下一条指令
    2. JVM栈：其中元素叫栈帧，存储局部变量表、操作栈、动态链接、方法出口等，栈的生命周期和线程相同
    3. Heap(堆)：被所有线程共享，在虚拟机启动时创建，功能是存放所有对象实例，同样还是垃圾回收器管理的主要区域。
    4. Method Area：方法区：被所有线程共享，用于存储已经被虚拟机加载的类信息、常量、静态变量，即使编译器编译出来的代码等数据
    5. 运行时常量池
        1. 存放编译器生成的：
            1. 各种字面量
            2. 符号引用
    6. Native Methods Stacks(本地方法栈)：线程所私有，功能类似于JVM
2. 具体图像参考PPT
3. 虚拟机栈是什么？有什么？
    1. 是一个后入先出的栈
    2. 每一个线程创建时，都会同时为这个线程创建一个私有的虚拟机栈
    3. 调用方法时，JVM会相应地创建一个栈帧进入虚拟机(存储数据和储存部分过程中的数据结构)，同时也可以处理动态链接、方法返回值和异常分派
    4. 线程对方法的调用就对应一个栈帧的入栈和出的过程，当前活动栈帧是虚拟机的栈顶元素
4. 栈帧是什么？有什么？见PPT
5. 方法区是什么？有什么？见PPT

6. String.intern():局部字符串池
    1. 在串池中添加一个字符串
    2. 栈帧中的局部变量表中的槽位是可以重用的
    >详见PPT中的代码块垃圾回收，重复使用槽位

## 3.5. 字节码指令集

### 3.5.1. 指令分类
+ 存储指令
+ 算术与逻辑运算指令
+ 类型转换指令
+ 对象创建和操作指令
+ 堆栈操作指令
+ 控制转移指令
+ 方法调用与返回指令

### 3.5.2. 前后缀

前后缀|操作数类型
--|--
i|整数
l|长整数
s|短整数
b|字节
c|字符
f|单精度浮点数
d|双精度浮点数
z|布尔值
a|引用

### 3.5.3. 加载和存储指令
1. 加载和存储指令用于将数据从栈帧的局部变量表和操作数栈之间来回传输
    1. 将一个局部变量加载到操作数栈的指令
    2. 将一个数值从操作数栈掉存储到局部变量表的指令
    3. 将常量加载到操作数栈的指令
    4. 局部变量表的访问索引指令
2. 一部分以尖括号结尾的指令代表了一组指令

### 3.5.4. 运算指令
1. 算术指令用于对两个操作数栈上的值进行操作，并把结果重新存回操作帧顶。
2. 处理除法是若除数为0，则虚拟机会抛出异常
3. 在处理浮点数时，使用最接近数舍入模式
    + 所有数会被舍入到适当精度
    + 如果两种可表示的形式与该值一样，会优先选择最低有效位为零的
4. 浮点数想整数进行转换，使用IEEE754标准下的像零舍入，截断数字

### 3.5.5. 类型转换指令
1. 类型转换指令将两种java虚拟机是数值类型相互转换，常用于用户操作时的显式类型转换操作。
2. JVM直接仅支持宽化类型转换(小范围到大范围类型转换)
    1. int => long,double,float
    2. long => float,double
    3. float => double
3. java虚拟机处理窄化类型：
    1. 显式使用转换指令来完成
    2. 将int和long窄化成T时，舍弃T以外的全部字节
    3. 将浮点值转化成int或者long时:
        1. NaN => 0
        2. 使用IEEE754向零舍入，获得整数
        3. 否则，根据正负转化成为相应的最大值

### 3.5.6. 对象创建于访问命令
1. 对于类实例和数组的创建和操作的指令并不相同
2. 

### 3.5.7. 操作数栈管理指令

### 3.5.8. 控制转移指令

### 3.5.9. 方法调用和返回指令

### 3.5.10. 异常处理指令

### 3.5.11. 同步指令

## 3.6. 字节码在虚拟机中的执行

### 3.6.1. 类的声明周期
1. 加载
2. 连接
    1. 验证
    2. 准备
    3. 解析
3. 初始化
4. 使用
5. 卸载
6. 详情见PPT

## 3.7. java指令和字节码

### 3.7.1. 变量
1. 局部变量:  
`int i = 69;`=>  
`0:bipush 69 => 2:istore_0(将这个值存储到0号槽中)`
2. 成员变量:向成员变量中赋值，需要知道对象、类型、名称等
`public int i = 100;`=>  
```
1:aload_0
2:bipush 100(添加100)
4:putfield #2(存储到2中去)
```

### 3.7.2. 条件语句

1. if-else:注释：  
`if_icmple 7`:如果20<=10，调向第七条指令
2. Switch
3. String Switch

### 3.7.3. 循环语句
1. while
2. do while

### 3.7.4. 方法调用

1. 字节码中#后面的是标签