<!-- TOC -->

- [1. 命名规范](#1-命名规范)
- [2. Java文件样式](#2-java文件样式)
  - [2.1. 版权信息：版权信息必须在java文件的开头](#21-版权信息版权信息必须在java文件的开头)
  - [2.2. Package和Imports：](#22-package和imports)
  - [2.3. Class](#23-class)
  - [2.4. 方法](#24-方法)
  - [2.5. 构造函数](#25-构造函数)
  - [2.6. 例子们](#26-例子们)
- [3. 代码编写格式](#3-代码编写格式)
  - [3.1. 代码样式](#31-代码样式)
  - [3.2. 文档化 javadoc](#32-文档化-javadoc)
  - [3.3. 缩进](#33-缩进)
  - [3.4. 页宽](#34-页宽)
  - [3.5. 括号](#35-括号)
- [4. 程序编写规范](#4-程序编写规范)
  - [4.1. exit()函数](#41-exit函数)
  - [4.2. 异常声明](#42-异常声明)
  - [4.3. 垃圾收集](#43-垃圾收集)
  - [4.4. final类](#44-final类)
  - [4.5. 访问类的成员变量](#45-访问类的成员变量)
- [5. 编程技巧](#5-编程技巧)
  - [5.1. byte数组转换成characters](#51-byte数组转换成characters)
  - [5.2. Utility类(仅仅提供方法的类)](#52-utility类仅仅提供方法的类)
  - [5.3. 枚举类型](#53-枚举类型)
  - [5.4. Swing](#54-swing)
  - [5.5. 调试](#55-调试)
  - [5.6. 性能](#56-性能)
  - [5.7. 使用StringBuffer对象](#57-使用stringbuffer对象)
  - [5.8. 避免synchroized关键字](#58-避免synchroized关键字)
  - [5.9. 换行](#59-换行)
  - [5.10. 使用有意义的名称封装复杂决策](#510-使用有意义的名称封装复杂决策)
  - [5.11. 表驱动编程](#511-表驱动编程)

<!-- /TOC -->

**Java学习笔记之java编码规范**
1. 这是关乎开发效率和后期维护的考虑
2. 2019/06/17 by stormbroken

# 1. 命名规范
1. 增加可读性，减少项目组中因为换人而带来的损失
2. 具体的规范
    1. Package:由一个小写单词组成
    2. Class:有大写字母开头，其他字母都小写的单词
    3. Class的变量、参数：由一个小写字母开头，后面的单词由大写字母开头
    4. static & final 的变量:都应该大写，并且指出完整含义
    5. 方法的参数：尽量保证和要赋值的字段名字相同

# 2. Java文件样式
1. 所有的java文件都应该遵守如下的样式规则

## 2.1. 版权信息：版权信息必须在java文件的开头
+ 比如:其他不需要出现在javadoc中的信息也可以包含在这里，参见例一

## 2.2. Package和Imports：
package在import前，import中的标准包名要在本地包名前，并且按照字母顺序排列，其中*保证导入所有的信息

## 2.3. Class
1. 类的注释，一般是用来解释类的，(参见例二)
2. 类定义
3. 类的成员变量:public的成员变量必须生成文档(JavaDoc)，protected、private、package定义的成员变量如果名字含义明确，可以没有注释

## 2.4. 方法
1. 存取方法：类变量的存取方法，可以简单地把只用于存取的方法写在一行上
2. 克隆方法：如果一个类是可以被克隆的，下一步就是clone方法，（例三）
3. 类方法：
    1. toString方法：每一个类都应该有的方法
    2. 其他方法
4. main方法：应当被写在类的底部

## 2.5. 构造函数
构造函数应该按照递增的方式写，参数多的写在后面，(并且访问类型应该在一行中，方法和参数写下一行)

## 2.6. 例子们
```java
/**(例一) 
* Copyright ? 2000 Shanghai XXX Co. Ltd. 
* All right reserved. 
*/ 
```
```java
/** 
* A class representing a set of packet and byte counters 
* It is observable to allow it to be watched, but only 
* reports changes when the current set is complete 
*/ 
```
```java
public 
Object clone() { 
    try { 
        CounterSet obj = (CounterSet)super.clone(); 
        obj.packets = (int[])packets.clone(); 
        obj.size = size; 
        return obj; 
    }catch(CloneNotSupportedException e) { 
        throw new InternalError("Unexpected CloneNotSUpportedException: " + e.getMessage()); 
    } 
} 
```

# 3. 代码编写格式

## 3.1. 代码样式
+ 代码应该使用unix的格式，而不是windows格式
    + 回车变为回车+换行

## 3.2. 文档化 javadoc
+ 必须用javadoc来生成文档
    1. 是文档的标准，被各种java编译器都认可的方法
    2. @author标记不被推荐

javadoc|功能
--|--
@author|作者
@version|版本
@see|引用
@since|最早
@deprecated|引起不推荐使用的警告
@param|参数
@return|返回
@throws|抛出异常

## 3.3. 缩进
+ 缩进每行两个空格，而不是一个Tab，因为Tab在不同设置不同编译器中是不同的

## 3.4. 页宽
+ 页宽设置为80字符
+ 特别长的剧应该一个逗号或者操作符后折行，并且折行后比原来的语句在缩进2个字符

## 3.5. 括号
+ 左括号和后一个字符之间不应该出现空格
+ 右括号和前一个字符之间不应该出现空格
+ 避免在语句中使用无意义的括号，括号只应该为达到某种目的而出现在源代码中

# 4. 程序编写规范

## 4.1. exit()函数
1. exit除了在main中可以被调用外，其他地方不应该调用，因为这样子不给任何代码机会来截获退出
2. 一个类似后台五福的程序不应该因为某一个库模块决定要退出就退出

## 4.2. 异常声明
1. 申明的错误应该抛出一个RuntimeException或者派生的异常
2. 顶层main函数应截获所有的异常，并且打印在屏幕上\记录在日志中

## 4.3. 垃圾收集
1. java使用成熟的后台垃圾收集技术来代替引用技术
2. 这样子做的话，必须要在使用完对象的实例后进行清场工作

## 4.4. final类
1. 不要因为性能的原因将一个类定义为final的，除非框架需要
    1. 如果一个类还没被准备好进行继承，最好在类文档中注明，而不要定义为final的
    2. 有可能在以后会用到相应的继承

## 4.5. 访问类的成员变量
1. 大部分类的成员变量应该定义为protected的来放置继承类使用他们

# 5. 编程技巧

## 5.1. byte数组转换成characters
使用`.getBytes()`即可

## 5.2. Utility类(仅仅提供方法的类)
这个类应该被申明为防止被继承或被初始化

## 5.3. 枚举类型
1. 定义的部分可以在之间使用==进行比较
2. 但是和其他的等价部分只能使用equal进行比较

## 5.4. Swing
1. 避免使用AWT组件
2. 尽量避免混合使用AWT和Swing组件
3. AWT组件不要用JscrollPane类来实现滚动使用AWT ScrollPane
4. 避免在InternalFrame组件中使用AWT组件

## 5.5. 调试
1. 一个重要的部分
2. 在软件生命周期的各个部分，吊事能够用配置开、关是最基本的。

## 5.6. 性能
1. 时刻记住我们应该注意代码的效率
2. 当我们没有时间实现一个高效的算法时，我们需要在文档中记录下来，以后有空的时候在实现她。

## 5.7. 使用StringBuffer对象
1. 保障减少很多不必要的创建和释放对象的时间

## 5.8. 避免synchroized关键字
1. 防止死锁
2. 保障程序的可移植性

## 5.9. 换行
1. 尽量用println来代替在字符串中使用"\n"

## 5.10. 使用有意义的名称封装复杂决策
如果程序的跳转逻辑比较复杂，我们可以考虑将判断逻辑单独封装

## 5.11. 表驱动编程
我们可以将特别复杂的决策(比如边界条件)，使用矩阵打表法。