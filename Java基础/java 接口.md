<!-- TOC -->

- [1. Deadly Dlamond](#1-deadly-dlamond)
- [2. 相关语句](#2-相关语句)
- [3. 特点](#3-特点)
- [4. 具体类和接口的使用](#4-具体类和接口的使用)
- [5. 链表的例子](#5-链表的例子)
- [6. 栈的例子](#6-栈的例子)
- [7. 字节码解释](#7-字节码解释)
- [8. default 默认方法](#8-default-默认方法)

<!-- /TOC -->
**接口**
1. 为了实现外部定义与内部实现彻底分离，达到"相同接口，多种实现"的目的，java小红提供了"接口"
# 1. Deadly Dlamond
1. java不支持多重继承，但是c++支持多重继承
2. 而java允许多个接口

# 2. 相关语句
1. 定义方式: `public interface name{}`
2. 使用方式: `public class name implements name`

# 3. 特点
1. 纯抽象类，没有任何方法的定义，仅仅持有这些方法的声明
    1. 接口中的数据成员在自动是static和final的，它们不能是空final，但是可以被非常量表达式初始化。
    2. 其中的抽象方法需要全部的实现
        1. 接口方法在方法表中的位置不是固定的，调用方法需要查找
            1. invokeinterface会相对慢一些：需要在方法表中去查找
        2. 接口方法和抽象方法不可以相互替代
            1. 接口可以被类和接口多继承
            2. 但是抽象类只能被单继承
            3. 接口中没有this指针，没有构造函数，没有实例字段，无法保存状态，而抽象方法就可以
            4. 抽象类不能在java8中使用lambda表达式
            5. 在设计理念上，接口反映的是"like-a"关系，抽象类反映的是"is-a"关系
    3. 接口可以被嵌套在类或其他接口中
2. 我们可以通过继承接口来扩展接口

# 4. 具体类和接口的使用
1. 显示地使用具体的类
    1. 锁定某个具体的实现
    2. 丧失了可扩展性
    3. 丧失了灵活性
2. 按接口编程
    1. 增加开发的可并行性
    2. 栈：后入先进
    3. 队列：先进先出

# 5. 链表的例子
1. 链表无法进行快速的查询，链表只能从头遍历
2. 使用集合给的比要的要多
3. 增加了耦合性
4. 增加了出错了的概率

# 6. 栈的例子
1. Monitorable和stack组合
2. 你依赖的东西是否有问题
3. 不同类型的栈

# 7. 字节码解释
1. 详见PPT

# 8. default 默认方法
1. default关键字只能在接口中使用(使用在switch中的default不能用在抽象类中)
2. 这个用于解决为借口添加新方法而又不会破坏已有方法的实现，为升级旧接口且保持向后兼容提供了途径
3. 默认方法的继承问题：可以重写，参见PPT
4. 接口继承行为发生冲突时的解决规则：
    1. 使用super来调用父类中的方法
    2. 当接口继承行为发生冲突时的另一个规则是，类的方法声明优先于接口默认方法，无论该方法是具体的还是抽象的。
5. 接口方法不能重写:Object类中的`equals、hashCode、toString`
6. 接口中的静态方法必须是public的，这个修饰符可以省略，但是static修饰符不可以被省略
```java
default void hello(){
    System.out.println("hi.");
}
```